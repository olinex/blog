---
description: '本文章由olinex翻译, 转载请在页面开头标明出处'
---

# 简介

## 为分布式应用而生的分布式协调服务

ZooKeeper是一个开源的分布式协调服务, 用于分布式应用. 它提供了一系列简单的功能, 分布式应用可以基于此来实现同步, 配置维系以及组和命名空间等更高级别的服务. 它的设计有利于编程, 并使用了类似文件系统的目录树结构数据模型. 它以Java编写, 并绑定了Java和C的支持.

众所周知, 协调服务很难实现. 它们特别容易出现诸如**竞态**和**死锁**的错误. 实现ZooKeeper的目的就是为了减轻分布式应用从头开始构建分布式应用的难度.

## 设计目标

### 简单

ZooKeeper允许分布式应用通过共享的**分层命名空间**来互相协调, 该命名空间的组织方式类似于标准文件系统. 命名空间由数据寄存器 \(在ZooKeeper中称为znodes\)组成, 它们类似于文件和目录. 与用于存储的典型文件系统不同, ZooKeeper数据保留在内存中, 这意味着可以实现高吞吐量和低延迟.

因为对性能, 可用性, 严格的有序访问加以重视. ZooKeeper可以用在大型的分布式系统中. 可靠意味着它不会成为单点故障. 严格排序意味着在客户端上可以实现复杂的同步功能.

### 分布式

和它协调的分布式应用一样, ZooKeeper本身也可以在被称为集群的一组主机内进行复制. 组成ZooKeeper服务的服务器都必须彼此了解. 他们维护内存中的状态画像以及持久存储事务日志和快照. 只要大多数服务器可用, ZooKeeper服务都将可用.

当客户端连接到单个ZooKeeper服务器时, 由客户端维护一个TCP连接, 通过他可以发送请求, 获取响应, 获取监控事件和发送心跳. 如果与服务器的TCP连接断开, 则客户端会连接到其他的服务器.

![&#x6765;&#x6E90;&#x4E8E;&#x5B98;&#x65B9;&#x6587;&#x6863;\(http://zookeeper.apache.org/doc/r3.5.6/zookeeperOver.html\)](../.gitbook/assets/zkservice.jpg)

### 严格时序

ZooKeeper会为每个更新动作打上一个数字戳来表示所有ZooKeeper的动作顺序, 后续的操作可以通过这个顺序实现高级的功能, 例如同步功能.

### 高性能

在以读取为主的工作负载中, ZooKeeper非常快. ZooKeeper应用程序可以在数千台计算机上运行. 当读写比例为10:1时, 其性能最佳.

## 数据模型与分层命名空间

ZooKeeper提供的命名空间与标准文件系统的命名空间非常相似. 命名是由斜杠\(/\)分隔的一系列路径元素. 命名空间的每个节点都由路径标识.

![&#x6765;&#x6E90;&#x4E8E;&#x5B98;&#x7F51;&#x6587;&#x6863;\(http://zookeeper.apache.org/doc/r3.5.6/zookeeperOver.html\)](../.gitbook/assets/zknamespace.jpg)

### 节点与临时节点

与标准文件系统不同的是, ZooKeeper命名空间中的每个节点都可以具有与其关联的数据和子节点, 而文件系统内仅允许目录拥有子节点. ZooKeeper旨在存储需要协调的数据, 如状态信息, 配置, 位置信息等, 因此存储在每个节点上的数据通常非常小, 应当在一千个字节的范围内. 我们用znode来明确表示ZooKeeper数据节点.

znodes内部维护了一个统计数据结构, 其中包括用于数据更改, ACL更改和时间戳的版本号, 以允许进行缓存验证和协调更新. znode的数据每次更新时, 版本号都会增加. 同时, 每当客户端检索数据时, 都会接收到数据的版本.

存储在znode命名空间的数据其读写都是原子性. 通过读取将会获取znode关联的所有数据, 而写入将会替换所有数据. 每个节点都有一个访问控制列表\(ACL\), 用于限制谁可以执行操作.

ZooKeeper还有临时节点的概念, 只要创建这些临时节点的会话处于活动状态, 这些znode就会存在. 会话结束时, 将会自动删除znode.

### 有条件地更新和监控

ZooKeeper支持监控的概念. 客户端可以在znode上设置监控. 当znode更改时, 将触发并删除监控. 触发监控后, 客户端会收到一个数据包, 说明znode已经更新. 如果客户端与其中一个ZooKeeper服务器之间的连接断开了, 则客户端将会收到本地通知.

## 保证

ZooKeeper非常简单搞笑, 由于其目的是作为构建更加复杂的服务的基础, 因此他提供了一系列的保证:

* 顺序一致性 - 来自客户端的更行将按照其发送的顺序执行
* 原子性 - 更新只有成功或失败, 没有中间结果
* 唯一系统映像 - 无论客户端连接到哪个服务器, 客户端都讲看到相同的服务视图
* 可靠性 - 应用更新后, 此更新更将一直持续到客户端覆盖更新为止
* 及时性 - 确保系统的客户视图在特定时间范围内是最新的

